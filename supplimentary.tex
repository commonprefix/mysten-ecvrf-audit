\section{Supplementary Information}
\subsection{Adding Batch Verification Support}
The current ECVRF implementation in the fastcrypto library does not support batch verification. Batch verification can improve the efficiency of verifying multiple VRF proofs simultaneously. The batchable VRF proofs, as described in the paper by Badertscher et al.\cite{batch-ecvrf}, replace the $c$ component of the VRF proof with $U,V$ as calculated by the prover. The verifier then derives $c$ from the challenge generation function and checks two verification equations (as opposed to deriving two values $U,V$). By shifting the terms of the equations so they sum to zero, we can randomise them so that we only need to perform one (very long) multi-multiplication and some field operations. These optimizations can also be combined with the variant multi-multiplication functions provided by Dalek. The main practical cost to this approach is that $U,V$ are 32 bytes each instead of 16 bytes for $c$.

Batch-format proofs can be ``compressed'' to the standard form at negligible computational cost, if not verifying at the same time. Standard proofs can be made batch friendly, though the conversion cost is equivalent to a full verification.

We recommend exploring the addition of batch verification support to the ECVRF implementation in the fastcrypto library, following the approach described in the referenced paper. This could enhance the efficiency and performance of the library, particularly when verifying multiple VRF proofs at once.

\subsection{Secret Scalar and Nonce Derivation}
The ECVRF standard provides two separate notions of a proverâ€™s secret: the secret key SK and the secret scalar $x$. In general, the secret key is used in two places: first, to derive the public key and second to derive a prefix used in the nonce generation for proofs.

Suites deriving from P-256 have a simple structure, where the key, the scalar and the prefix are the same value (modulo representation of the secret as a bytestring for the prefix). Suites deriving from P-256 use RFC Section~5.4.2.1 to derive nonces.

Suites deriving from ed25519 have a more complex structure, where the key is a bytestring hashed into a 64 byte string, half of which is used to derive the secret scalar and half of which is used to derive the nonce as per RFC Section~5.4.2.2.

The current implementation uses the P-256 design for the secret scalar and the ed25519 design for the nonce. This does not directly contradict the guidance in the RFC as the hLen requirement of 64 mentioned in RFC Section~5.4.2.2 is met. We do not believe there exists an issue with this design choice: domain separation is not impacted and the contribution of the secret key to the nonce is similar. 

Note that it seems that aligning fully with either is not trivial: one either needs to follow the more complex HMAC design from P-256 or follow get the scalar derivation from ed25519 which includes operations that are unneeded in ristretto: part of it performs bit operations  with the intention of clearing the ed25519 cofactor which does not exist in the ristretto curve, so a degree of divergence may still be present.

